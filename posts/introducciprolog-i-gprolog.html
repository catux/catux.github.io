<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Associació d'usuaris de GNU/Linux de la Catalunya Central">
    <meta name="keywords" content="gnu/linux, linux, programari lliure, gnu, lug, associacio, manresa, sant joan de vilatorrada, catalan, català, catalunya">
    <meta name="author" content="Catux">
    <link rel="icon" href="https://catux.org/images/favicon.ico">

    <title>Catux - Associació d'usuaris de GNU/Linux de la Catalunya Central</title>

    <!-- Bootstrap 5 CSS is included in main.css -->
    <link rel="stylesheet" type="text/css" href="https://catux.org/css/main.css">
    <!-- Bootstrap 5 JS and dependencies are included in main.js -->
    <script src="https://catux.org/js/main.js" defer></script>
</head>
<body>
    <header class="sticky-top">
        <nav class="navbar navbar-expand-lg navbar-dark bg-dark py-3">
            <div class="container-fluid">
                <a class="navbar-brand" href="https://catux.org/">
                    <img src="https://catux.org/images/catuxlogo.png" alt="Catux" height="50" class="me-3">
                    <div class="d-none d-lg-block d-xl-none">Associació d'usuaris de GNU/Linux de la Catalunya Central</div>
                </a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarMain" aria-controls="navbarMain" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div id="navbarMain" class="collapse navbar-collapse">
                    <ul class="navbar-nav ms-auto mb-2 mb-lg-0">
                        <li class="nav-item"><a class="nav-link px-3" href="https://catux.org/post_list.html">Blog</a></li>
                        <li class="nav-item"><a class="nav-link px-3" href="https://catux.org/traduccio.html">Traducció</a></li>
                        <li class="nav-item"><a class="nav-link px-3" href="https://catux.org/contactar.html">Contactar</a></li>
                    </ul>
                </div>
            </div>
        </nav>
    </header>

    <div class="container main-container">
        
    <div class="container-fluid">

        <div class="post">
            <a href="https://catux.org/post_list.html">
                <i class="fas fa-chevron-left"></i>
                Arxius
            </a>

            <h1>
                
        Introducció a Prolog i gprolog
    
            </h1>

            <h3>
                Escrit al
                
        2006-01-11 00:00:00
    
                per
                
        cpina
    
            </h3>

            <p>
                
        <span class="noticia">En aquest article es veur&agrave; una introducci&oacute; al llenguatge de programaci&oacute; Prolog (explicant, molt per sobre, el paradigma de programaci&oacute; l&ograve;gic, diferent dels t&iacute;pics paradigmes imperatius o orientat a objectes, m&eacute;s coneguts).<br /> <br /> L&#39;article &eacute;s v&agrave;lid per qui coneix Prolog per&ograve; no sap utilitzar el compilador/int&egrave;rpret gprolog (lliure). Tamb&eacute; &eacute;s suficient per qui vol veure quins aspectes tenen els programes amb Prolog, amb alguns exemples, etc.<br /> <br /> Aix&ograve; s&iacute;, &eacute;s un tema una mica dur de llegir...</span> Ren&uacute;ncia de responsabilitat: malauradament no s&oacute;c un expert amb Prolog. Aix&iacute; que &eacute;s possible que s&#39;hagi utilitzat algun concepte de forma no el m&eacute;s adequada. S&#39;ha intentat que sigui f&agrave;cil de llegir, breu, per&ograve; no incorrecte. Si hi ha alguna errada m&#39;ho podeu fer arribar per correu electr&ograve;nic: <a href="mailto:%20carles%20ARROBA%20pinux.info">carles ARROBA pinux.info</a><br /> <br /> <h2>&Iacute;ndex</h2><br /> <br /> <div id="article" class="article_normal"><li><a href="http://www.catux.org/index.php?contingut=articles&amp;num=105#introduccio">Introducci&oacute;</a><br /> </li><li><a href="http://www.catux.org/index.php?contingut=articles&amp;num=105#instalar">Instal&middot;lar un compilador Prolog</a><br /> </li><li><a href="http://www.catux.org/index.php?contingut=articles&amp;num=105#primer">Primer programa amb Prolog</a><br /> </li><li><a href="http://www.catux.org/index.php?contingut=articles&amp;num=105#ordre">Ordre d&#39;avaluaci&oacute;</a><br /> </li><li><a href="http://www.catux.org/index.php?contingut=articles&amp;num=105#seguir">Seguir una tra&ccedil;a</a><br /> </li><li><a href="http://www.catux.org/index.php?contingut=articles&amp;num=105#llegir">Llegir el codi d&#39;un fitxer</a><br /> </li><li><a href="http://www.catux.org/index.php?contingut=articles&amp;num=105#compilacio">Compilaci&oacute;</a><br /> </li><li><a href="http://www.catux.org/index.php?contingut=articles&amp;num=105#exemples">Petits exemples</a><br /> </li><li><a href="http://www.catux.org/index.php?contingut=articles&amp;num=105#reflexio">Reflexi&oacute;</a><br /> </li><li><a href="http://www.catux.org/index.php?contingut=articles&amp;num=105#enllacos">Enlla&ccedil;os</a><br /> <br /> <br /> <a name="introduccio" title="introduccio"></a><h2>Introducci&oacute;</h2><br /> Molta gent programa en llenguatges de programaci&oacute; molt t&iacute;pics. Segur que sona molt familiar C, C++, Java, Perl, Python, scripts en Bash, etc.<br /> <br /> Tots aquests llenguatges de programaci&oacute; tenen un paradigma quasi com&uacute;: o b&eacute; s&oacute;n llenguatges imperatius o b&eacute; s&oacute;n llenguatges orientats a objectes (a m&eacute;s a m&eacute;s normalment es pot veure l&#39;orientaci&oacute; a objectes com una capa per sobre dels imperatius).<br /> <br /> Es poden anomenar els seg&uuml;ents paradigmes de programaci&oacute; (en alguns casos estan combinats):<br /> <br /> <br /> </li><li><strong>Imperatiu.</strong> Per exemple C. Aquest paradigma inclou assignacions, bucles, funcions, etc.<br /> </li><li><strong>Orientat a objectes.</strong> C++ i Java segurament s&oacute;n els m&eacute;s famosos. Simula &eacute;s considerat el primer llenguatge de programaci&oacute; orientat a objectes, i Smalltalk &eacute;s considerat un predecessor de Java. Inclou objectes, instanciar-ne, fer-ne de nous, m&eacute;todes, etc.<br /> </li><li><strong>Programaci&oacute; funcional.</strong> Lambda calculus &eacute;s considerat el primer llenguatge funcional. Uns m&eacute;s moderns poden ser LISP (una implementaci&oacute; lliure &eacute;s CLISP). Per entendre-ho en breus paraules, utilitzant programaci&oacute; funcional &quot;pura&quot; no hi ha assignaci&oacute; de variables ni bucles iteratius. S&#39;evita qualsevol tipus d&#39;efecte col&middot;lateral pel fet d&#39;executar una funci&oacute;.<br /> </li><li><strong>Programaci&oacute; l&ograve;gica.</strong> El m&eacute;s fam&oacute;s &eacute;s Prolog (Logic Programming). No hi ha iteracions com a tal, ni funcions, ni condicionals. Quan es comenta aix&ograve; tothom t&eacute; curiositat... i com es programa? Ho veurem.<br /> </li><li><strong>Programaci&oacute; orientada a events.</strong> Enlloc de ser totalment seq&uuml;encial, dep&eacute;n de l&#39;interacci&oacute; que faci l&#39;usuari amb el programa. La programaci&oacute; visual sol utilitzar aquest tipus de paradigma. <br /> <br /> <br /> Hi ha molta informaci&oacute; sobre aquest tema a la Wikipedia. <a href="http://en.wikipedia.org/wiki/Programming_paradigm">Paradigmes de programaci&oacute;</a> (tamb&eacute; en <a href="http://es.wikipedia.org/wiki/paradigma_de_programaci%C3%B3n">castell&agrave;</a>), article que <a href="http://en.wikipedia.org/wiki/Programming_paradigm#Examples">t&eacute; enlla&ccedil;os</a> a varis articles amb els paradigmes de programaci&oacute; comentats anteriorment i altres.<br /> <br /> En aquest article s&#39;intentar&agrave; satisfer la curiositat de veure un parell de programes en Prolog, per&ograve; no s&#39;explicar&agrave; (ni molt menys) totes les possibilitats de Prolog, com funciona internament, etc. Per comen&ccedil;ar caldria una base de matem&agrave;tica l&ograve;gica que no s&#39;explicar&agrave;, sin&oacute; que nom&eacute;s es vol veure una petita mostra de qu&egrave; es pot fer i com es pot fer. L&#39;article tamb&eacute; &eacute;s &uacute;til per qui coneix alguna altra implementaci&oacute; de Prolog (com pot ser Visual Prolog) i vol donar els primers passos amb gprolog. La programaci&oacute; &eacute;s semblant per&ograve; primer un es pot sentir una mica desorientat de la nova manera d&#39;interactuar amb el compilador.<br /> <br /> <a name="instalar" title="instalar"></a><h2>Instal&middot;lant un compilador de Prolog</h2><br /> Els dos compiladors lliures m&eacute;s utilitzats de Prolog s&oacute;n <a href="http://pauillac.inria.fr/%7Ediaz/gnu-prolog/">gprolog</a> (gnu-Prolog) i <a href="http://www.swi-prolog.org/">swi-prolog.</a> En aquest article es far&agrave; servir gprolog, tot i que amb swi-prolog seria molt semblant. Els dos accepten tenir funcions realitzades amb C (seguint certa nomenclatura) aix&iacute; que no ens hauriem de sentir limitats en cap aspecte (en el sentit que, si Prolog no tingu&eacute;s sockets podriem fer un wrapper a les crides de sockets en C).<br /> <br /> En Debian (o Ubuntu, etc.) es pot instal&middot;lar el paquet &quot;gprolog&quot;. A altres distribucions segurament hi ha un paquet equivalent. Aquest paquet cont&eacute; compilador (per si volem generar binaris executables, com es fa amb el &quot;gcc&quot;) i tamb&eacute; l&#39;int&egrave;rpret (que facilita el proc&eacute;s de proves i aprenentatge).<br /> <br /> Un cop el tenim instal&middot;lat podem executar-lo amb &quot;gprolog&quot;. gprolog quedar&agrave; a l&#39;espera de noves ordres:<br /> <br /> carles@pinux:~$ gprolog<br /> GNU Prolog 1.2.18<br /> By Daniel Diaz<br /> Copyright (C) 1999-2004 Daniel Diaz<br /> | ?- <br /> <br /> <br /> Si es vol sortir de gprolog s&#39;ha d&#39;executar el predicat &quot;halt&quot;. Tot predicat amb Prolog acaba amb &quot;.&quot;. Per tant, per sortir, s&#39;executar&agrave;:<br /> <br /> halt.<br /> <br /> <br /> <a name="primer" title="primer"></a><h2>Primer programa en prolog</h2><br /> Prolog no &eacute;s com un dels llenguatges imperatius m&eacute;s freq&uuml;entment coneguts, sin&oacute; que es basa en &quot;fets&quot; (facts) i &quot;regles&quot; (rules).<br /> <br /> <h3>Els fets</h3> <br /> El conjunt de fets formaran una base de dades de coneixement. Prolog consultar&agrave; aquests fets per saber certa informaci&oacute;. Un exemple de fet &eacute;s:<br /> <br /> persona(jordi).<br /> <br /> <br /> &Eacute;s a dir, indiquem que &quot;jordi&quot; S&Iacute; que &eacute;s una persona. Prolog assumeix que qualsevol fet no conegut &eacute;s fals (assumpci&oacute; del m&oacute;n tancat).<br /> <br /> Cal tamb&eacute; indicar que &quot;jordi&quot;, com que &eacute;s una cadena, ha d&#39;anar en min&uacute;scules (o entre cometes). Si s&#39;escriu &quot;Jordi&quot; Prolog interpretar&agrave; que &eacute;s un s&iacute;mbol.<br /> <br /> Ara es veur&agrave; com es pot fer amb gprolog. S&#39;executar&agrave; gprolog, i s&#39;escriur&agrave; &quot;consult(user).&quot;. La regla &quot;consult&quot; llegeix un fitxer &quot;.pl&quot; per treballar-hi, per&ograve; el cas especial &quot;user&quot; serveix perqu&eacute; esperi l&#39;entrada de teclat.<br /> <br /> Llavors escriurem &quot;persona(jordi).&quot;. Si no es volen escriure m&eacute;s fets, es far&agrave; &quot;Control+D&quot; (per indicar que ja ha acabat l&#39;entrada de teclat).<br /> <br /> Si llavors s&#39;escriu &quot;persona(joan).&quot; ens dir&agrave; &quot;No&quot;. En canvi si s&#39;executa &quot;persona(jordi).&quot; contestar&agrave; &quot;yes&quot;, ja que en &quot;jordi&quot; &eacute;s una persona. Veiem-ho:<br /> <br /> <br /> carles@pinux:~$ gprolog<br /> GNU Prolog 1.2.18<br /> By Daniel Diaz<br /> Copyright (C) 1999-2004 Daniel Diaz<br /> | ?- consult(user).<br /> compiling user for byte code...<br /> persona(jordi).<br /> <br /> user compiled, 2 lines read - 236 bytes written, 5062 ms<br /> <br /> (1 ms) yes<br /> | ?- persona(joan).<br /> <br /> no<br /> | ?- persona(jordi).<br /> <br /> yes<br /> | ?- <br /> <br /> <strong>Nota:</strong> Prolog interpreta els &quot;textes&quot; en min&uacute;cula com a cadenes, en canvi si comencen amb maj&uacute;scula com simbols (un tipus de variables). Aix&iacute; que &eacute;s case-sensitive i cal anar en compte per aix&ograve;.<br /> <br /> <h3>Les regles</h3><br /> Normalment es treballa en conjuncions (AND&#39;s) i les regles s&oacute;n certes quan tots els fets o regles del seu llistat s&oacute;n certs. En el seg&uuml;ent exemple es defineixen 4 fets (es defineix una persona que es diu &quot;jordi&quot;, un gos que es diu &quot;showen&quot;, un mascle que &eacute;s en &quot;jordi&quot; i una femella, la &quot;showen&quot;). Finalment es fa una regla: X ser&agrave; home si &eacute;s una persona i &eacute;s mascle.<br /> <br /> persona(jordi).<br /> gos(showen).<br /> mascle(jordi).<br /> femella(showen).<br /> <br /> home(X):-persona(X),mascle(X).<br /> <br /> Estrictament aquesta regla diu &quot;ser home implica ser persona i ser mascle&quot;. Es pot entendre com &quot;si &eacute;s persona i mascle &eacute;s un home&quot;. O b&eacute; &quot;ser&agrave; un home si &eacute;s una persona i &eacute;s mascle&quot;.<br /> <br /> Repetint els passos de l&#39;apartat anterior (gprolog, consult(user)., escriure els fets, control+D) llavors es pot executar:<br /> <br /> | ?- home(showen).<br /> <br /> no<br /> | ?- home(jordi).<br /> <br /> yes<br /> | ?- <br /> <br /> Es pot veure que la X en la &uacute;ltima regla &eacute;s una variable, l&#39;&agrave;mbit de les quals nom&eacute;s &eacute;s el de la regla definida.<br /> <br /> <h3>Entrada/sortida</h3><br /> Prolog intenta interpretar els predicats tan com si s&oacute;n d&#39;entrada com si s&oacute;n de sortida. Si es fan aquests fets:<br /> <br /> <br /> persona(jordi).<br /> persona(carla).<br /> persona(maria).<br /> persona(joan).<br /> <br /> <br /> Ja se sap que es pot demanar &quot;jordi &eacute;s una persona&quot;? I contestar&agrave; &quot;yes&quot; o &quot;no&quot;. Per&ograve; amb Prolog tamb&eacute; es pot fer &quot;digues totes les persones&quot; (pregunta molt simple aquest cas per&ograve; que pot tenir gr&agrave;cia altres casos):<br /> <br /> persona(Y).<br /> <br /> Retornar&agrave;:<br /> <br /> | ?- persona(Y).<br /> <br /> Y = jordi ? ;<br /> <br /> Y = carla ? ;<br /> <br /> Y = maria ? ;<br /> <br /> Y = joan<br /> <br /> (1 ms) yes<br /> | ?- <br /> <br /> Veure que, per tal de continuar, amb gprolog cal presionar &quot;;&quot; (en altres Prologs pot no fer falta).<br /> Tamb&eacute; es pot presionar &quot;a&quot;, que indica &quot;all&quot; i donar&agrave; tots els resultats seguits.<br /> Per tant, amb aquest conjunt de predicats tan es pot demanar &quot;&eacute;s jordi una persona?&quot; com &quot;digues totes les persones&quot; (o, afegint fets i una regla, totes les dones, homes, etc.)<br /> <br /> <a name="ordre" title="ordre"></a><h2>Ordre d&#39;avaluaci&oacute;</h2><br /> Prolog, quan es troba una regla, intenta veure si els fets que la componen, i d&#39;esquerre a dreta, s&oacute;n certs. Primer comprova el de m&eacute;s a l&#39;esquerre, a continuaci&oacute; el seg&uuml;ent, etc.<br /> <br /> En cas que una regla no sigui certa, intenta aplicar backtracking. Aix&ograve; &eacute;s, si una regla o un fet pot tenir varis resultats i havia agafat el primer, intentar&agrave; provar-ho amb el segon. Tot aix&ograve; autom&agrave;tic, ens ve gratis amb Prolog! No s&#39;ha d&#39;implementar backtracking, ho fa sol. Per fer-se una idea, a l&#39;entrada de la Wikipedia hi ha implementat l&#39;algorisme d&#39;ordenaci&oacute; Quicksort amb 5 regles (Quicksort &eacute;s un algorisme recursiu, idoni per implementar-lo amb Prolog). Amb C ocuparia segurament mitja p&agrave;gina o una p&agrave;gina, i molt m&eacute;s enrevessat.<br /> <br /> <a name="seguir" title="seguir"></a><h2>Seguir una tra&ccedil;a</h2><br /> Un fet &eacute;s una regla que &eacute;s certa sempre. Per tant com a fet es pot tenir una regla del tipus:<br /> <br /> home(jordi):-write(jordi),nl.<br /> <br /> (nl: new line, salt de l&iacute;nia)<br /> La regla anterior escriu &quot;jordi&quot; per pantalla, i fa un salt de l&iacute;nia. Tant el predicat &quot;write&quot; com &quot;nl&quot; tornen cert, aix&iacute; que si s&#39;intenta saber si hi ha un home anomenat &quot;jordi&quot;, s&#39;escriur&agrave;, es far&agrave; un salt de l&iacute;nia i ser&agrave; cert que hi ha un home anomenat &quot;jordi&quot;. Aix&ograve; pot ajudar per seguir la tra&ccedil;a d&#39;alguna execuci&oacute;.<br /> <br /> Ara es far&agrave;:<br /> <br /> persona(jordi):-write(pjordi),nl.<br /> persona(carla):-write(pcarla),nl.<br /> persona(maria):-write(pmaria),nl.<br /> persona(joan):-write(pjoan),nl.<br /> <br /> mascle(jordi):-write(mjordi),nl.<br /> mascle(joan):-write(mjoan),nl.<br /> <br /> femella(carla):-write(fcarla),nl.<br /> femella(maria):-write(fmaria),nl.<br /> <br /> dona(X):-persona(X),femella(X).<br /> <br /> <br /> I com a regla per executar, es fa:<br /> <br /> dona(Y).<br /> <br /> Presionant &quot;;&quot; es veuran els dos resultats que hi ha, per&ograve; a m&eacute;s a m&eacute;s es pot comprovar l&#39;ordre d&#39;avaluaci&oacute; comentat anteriorment.<br /> <br /> <a name="llegir" title="llegir"></a><h2>Llegir el codi d&#39;un fitxer</h2><br /> Fins ara s&#39;han fet petites execucions, escrivint cada cop l&#39;entrada, per&ograve; en programes m&eacute;s llargs aix&ograve; &eacute;s inc&ograve;mode. Si es vol tenir en un fitxer, es far&agrave; un fitxer de nom &quot;programa.pl&quot; amb el conjunt de fets i regles, i llavors des de gprolog:<br /> <br /> consult(programa).<br /> <br /> Si es copien els anteriors fets i regles dins un fitxer, es faria de la seg&uuml;ent forma:<br /> <br /> carles@pinux:~$ gprolog<br /> GNU Prolog 1.2.18<br /> By Daniel Diaz<br /> Copyright (C) 1999-2004 Daniel Diaz<br /> | ?- consult(programa).<br /> compiling /home/carles/programa.pl for byte code...<br /> /home/carles/programa.pl compiled, 12 lines read - 1922 bytes written, 24 ms<br /> <br /> (1 ms) yes<br /> | ?- dona(Y).<br /> <br /> <br /> <a name="compilacio" title="compilacio"></a><h2>Compilaci&oacute;</h2><br /> Potser es desitja generar un fitxer executable amb un programa que s&#39;hagi fet amb Prolog. En aquest cas el proc&eacute;s &eacute;s una mica diferent. Per exemple, es pot tenir un fitxer amb el seg&uuml;ent contingut:<br /> <br /> inicial:-dona(Y),write(adeu),nl,halt.<br /> <br /> persona(jordi):-write(pjordi),nl.<br /> persona(carla):-write(pcarla),nl.<br /> persona(maria):-write(pmaria),nl.<br /> persona(joan):-write(pjoan),nl.<br /> <br /> mascle(jordi):-write(mjordi),nl.<br /> mascle(joan):-write(mjoan),nl.<br /> <br /> femella(carla):-write(fcarla),nl.<br /> femella(maria):-write(fmaria),nl.<br /> <br /> dona(X):-persona(X),femella(X).<br /> <br /> :-initialization(inicial).<br /> <br /> El &quot;initialization&quot; vindria a ser com el &quot;main&quot; de C, per on comen&ccedil;a el programa. &Eacute;s un fet, i executar&agrave; &quot;inicial&quot;. Al final de &quot;inicial&quot; hi ha halt, en cas contrari quan un usuari executi aquest fitxer hi haur&agrave; prolog a l&#39;espera de noves ordres.<br /> <br /> Per compilar-lo &eacute;s de la seg&uuml;ent forma:<br /> <br /> carles@pinux:~/catux/prolog$ gplc comp.pl <br /> comp.pl:1 warning: singleton variables [Y] for inicial/0<br /> carles@pinux:~/catux/prolog$ <br /> <br /> El warning &eacute;s perqu&eacute; la variable Y no es fa servir enlloc m&eacute;s (&eacute;s com un &quot;unusued variable&quot;). Amb Prolog hi ha una variable anomenada an&ograve;nima, representada amb el car&agrave;cter &quot;_&quot;. Si canviem la Y per la variable an&ograve;nim ja no ens mostrar&agrave; aquest warning.<br /> <br /> <a name="exemples" title="exemples"></a><h2>Petits exemples</h2><br /> Hi ha una s&egrave;rie d&#39;exemples, t&iacute;pics de Prolog (relacionats amb representaci&oacute; del coneixement) que s&oacute;n molt intu&iuml;tius (i f&agrave;cils de trobar a Internet).<br /> En canvi hi ha exemples amb poca tradici&oacute; de Prolog, que la gent li sembla dif&iacute;cil de fer en Prolog que no ho s&oacute;n tant. Aqusts s&oacute;n els que es veuran a continuaci&oacute;.<br /> <h3>Majoria d&#39;edat (i predicat cut)</h3><br /> Demanar&agrave; a l&#39;usuari que escrigui la seva edat, i dir&agrave; si &eacute;s menor o major d&#39;edat.<br /> Una primera aproximaci&oacute; &eacute;s:<br /> <br /> major :- write(&#39;Escriu la teva edat: &#39;),read(EDAT),comprova(EDAT).<br /> comprova(E) :- E&amp;gt;=18,write(&#39;Ets major d edat&#39;),nl.<br /> comprova(E) :- E&amp;lt;18,write(&#39;Ets menor d edat&#39;),nl.<br /> <br /> <br /> Prolog escriu la pregunta, llegeix la resposta i comprova l&#39;edat. Veure que si un &eacute;s major, entra a la primera regla (el primer predicat &eacute;s cert -E&amp;gt;=18-, per tant passa al segon predicat -write- que retorna cert i finalment escriu una nova l&iacute;nia). Despr&eacute;s Prolog, que intenta trobar totes les solucions, fa el mateix amb la segona, que no es compleix (ja que E no ser&agrave; menor que 18 si era major).<br /> <br /> <strong>Nota:</strong> quan l&#39;usuari escriu l&#39;edat cal acabar amb un &quot;.&quot;. Si t&eacute; 20 anys, l&#39;usuari ha d&#39;escriure &quot;20.&quot;<br /> <br /> Si s&#39;hagu&eacute;s fet, pensant amb una estructura if then else:<br /> <br /> comprova(E) :- E&amp;gt;=18,write(&#39;Ets major d edat&#39;),nl.<br /> comprova(E) :- write(&#39;Ets menor d edat&#39;),nl.<br /> <br /> Quan &eacute;s major d&#39;edat tamb&eacute; escriure que &eacute;s menor. La primera regla es compliria, i la segona tamb&eacute;. En aquest cas, es pot utilitzar el predicat &quot;cut&quot; a la primera regla, que indica que si s&#39;ha arribat al &quot;cut&quot; (representat per &quot;!&quot;) no es faci backtracking en la regla que es trobi:<br /> <br /> major :- write(&#39;Escriu la teva edat: &#39;),read(EDAT),comprova(EDAT).<br /> comprova(E) :- E&amp;gt;=18,write(&#39;Ets major d edat&#39;),nl,!.<br /> comprova(E) :- write(&#39;Ets menor d edat&#39;),nl.<br /> <br /> <br /> <h3>Comptador endarrera</h3><br /> En aquest cas es far&agrave; un comptador endarrera. &Eacute;s a dir, comptar de 10 fins a 0:<br /> <br /> comptar(X) :- X&amp;gt;0,write(X),nl,Y is X-1,comptar(Y),write(&#39;retornant&#39;).<br /> comptar(_) :- write(&#39;FINAL&#39;),nl.<br /> <br /> I el predicat a executar &eacute;s comptar(10).<br /> Si es prova, es veur&agrave; com demana que premem &quot;;&quot; si es volen m&eacute;s solucions (o b&eacute; &quot;a&quot; si les volem totes). El programa aquest &eacute;s recursiu, i com que tots els predicats hauran tornat cert interpreta que una soluci&oacute; &eacute;s pujar un nivell de recursivitat (quan est&agrave; fent el write de &quot;retornant&quot;), dos nivells, fins a tots els nivells.<br /> <br /> Si es vol evitar tenir totes les solucions es pot fer d&#39;aquesta manera:<br /> <br /> comptar(X) :- X&amp;gt;0,write(X),nl,Y is X-1,comptar(Y),!.<br /> comptar(_) :- write(&#39;FINAL&#39;),nl.<br /> <br /> Amb l&#39;ajuda del cut es quedar&agrave; a la primera soluci&oacute;, sense intentar trobar-ne m&eacute;s.<br /> <br /> <h3>Recorrer una llista</h3><br /> Amb Prolog l&#39;usuari pot definir nous tipus de dades (no es veur&agrave; aqu&iacute;) o b&eacute; utilitzar llistes (es pot fer un s&iacute;mil amb els arrays).<br /> <br /> Les llistes estan representades de la forma [10,12,8,7,15].<br /> <br /> Si es vol rec&ograve;rrer una llista es pot fer de la seg&uuml;ent manera:<br /> <br /> imprimir([H|T]):-write(H),write(&#39;-&#39;),imprimir(T).<br /> imprimir([]).<br /> <br /> I llavors comen&ccedil;ar l&#39;execuci&oacute; de la seg&uuml;ent forma:<br /> <br /> | ?- imprimir([10,20,10,40]).<br /> <br /> H i T s&oacute;n dues lletres qualsevol, que en cas volen dir &quot;Head&quot; i &quot;Tail&quot;. Head contindr&agrave; el primer element de la llista, Tail el dem&eacute;s. S&#39;imprimeix el qu&eacute; val el primer element (enlloc d&#39;imprimir es podria fer qualsevol operaci&oacute;, buscar un element, sumar, etc.) i es crida amb la resta de la llista.<br /> <br /> Cal la segona l&iacute;nia ( imprimir([]). ) ja que sin&oacute; imprimiria la llista per&ograve; acabaria amb &quot;no&quot; enlloc de &quot;yes&quot; (no es podria &quot;unificar&quot; quan la llista &eacute;s buida, ja que no tindria ja l&#39;estructura [H|T] requerida en la primera regla). Si acaba amb &quot;no&quot; seria dif&iacute;cil utilitzar aquestes regles en altres programes, ja que sempre fallaria al imprimir la llista.<br /> <br /> <h3>Sumar els elements d&#39;una llista</h3><br /> Aquest &eacute;s l&#39;&uacute;ltim exemple, de moment. Sumar&agrave; els elements d&#39;una llista:<br /> <br /> sumar([H|T],S_ENT,S_SURT):-write(H),write(&#39;-&#39;),sumar(T,S_ENT + H,Y),S_SURT is Y.<br /> sumar([],S_ENT,S_ENT).<br /> <br /> Si s&#39;executa (recordar fer un consult(user). o d&#39;un fitxer) es veur&agrave;:<br /> <br /> <br /> | ?- sumar([10,20,5,2],0,X).<br /> 10-20-5-2-<br /> <br /> X = 37<br /> <br /> (1 ms) yes<br /> | ?- <br /> <br /> El qu&eacute; fa, &eacute;s, enlloc d&#39;imprimir els n&uacute;meros, fer-ne sumes.<br /> <br /> Pot costar de veure, ja que normalment (si m&eacute;s no jo) s&#39;est&agrave; poc acostumat a la programaci&oacute; recursiva. S&#39;anir&agrave; cridant a cada imprimir amb la suma anterior m&eacute;s el n&uacute;mero actual. Quan s&#39;arribi a l&#39;&uacute;ltim &quot;sumar&quot; es retornar&agrave; per la sortida el S_ENT, ja que cal propagar-ho de tornada. De tornada es va retornant el Y, mitjan&ccedil;ant S_SURT, fins que Prolog ens ensenyar&agrave; el resultat.<br /> <br /> <a name="reflexio" title="reflexio"></a><h2>Reflexi&oacute;</h2><br /> Prolog &eacute;s un llenguatge de programaci&oacute; amb un paradigma que s&#39;hi est&agrave; poc habituat. Per programar b&eacute; en Prolog caldria no pensar &quot;en imperatiu&quot; i &quot;adaptar-ho&quot;, sin&oacute; directament pensar en Prolog.<br /> <br /> Hi ha una s&egrave;rie de casos, sobretot dins la representaci&oacute; de coneixement, que &eacute;s m&eacute;s natural fer-ho en Prolog que en altres llenguatges (tan natural que, tot i no saber gaire Prolog surten les regles sense pensar-ho).<br /> <br /> Hi ha altres casos que &eacute;s m&eacute;s natural fer-ho amb llenguatges imperatius. De totes maneres, des de Prolog es poden executar funcions en C (i vice-versa!) amb la qual cosa es pot tenir el millor dels dos mons junts.<br /> <br /> Per poder escollir el millor llenguatge per cada cos cal coneixer-los, sin&oacute; no es podr&agrave; escollir b&eacute;. El despreci a alguns llenguatges sol venir del desconeixement d&#39;aquests. <br /> <br /> <a name="enllacos" title="enllacos"></a><h2>Enlla&ccedil;os</h2><br /> <br /> </li><li><a href="http://contraintes.inria.fr/%7Ehaemmerl/gprolog-rh/doc/manual073.html">Cridar codi C des de Prolog.</a><br /> </li><li><a href="http://en.wikibooks.org/wiki/Prolog">Llibre de Wikibooks</a> sobre programaci&oacute; amb Prolog.<br /> </li><li><a href="http://www.monografias.com/trabajos5/prolog/prolog.shtml">Un curs de gprolog</a><br /> <br /> <br /> <h2>Nota</h2><br /> Si alg&uacute; ha arribat aqui, &eacute;s possible que m&eacute;s endavant es faci un article continuaci&oacute; d&#39;aquest -amb dedicat&ograve;ria al lector/lectora- o b&eacute; un de la mateixa tem&agrave;tica per&ograve; amb Lisp.</li></div>
    
            </p>

            <h3>
                Categories:
                
        Articles
    
            </h3>

            <hr />
            <h1>Comentaris</h1>
            <ul class="list-group">
                
        <li class="list-group-item comment">Come on lads, give us another story<p class="comment-author">Escrit al 2009-12-01 14:42:24 per Susan Ho</p></li>
    
            </ul>


            <a href="https://catux.org/post_list.html">
                <i class="fas fa-chevron-left"></i>
                Arxius
            </a>
        </div>

    </div>


    </div> <!-- /.container -->

    <footer class="bg-dark text-light py-4 mt-5 fixed-bottom">
        <div class="container">
            <div class="row">
                <div class="col-md-8">
                    <p class="mb-0">
                        <small><small>Tot el contingut de Catux està subjecte sota la nova versió de la llicència de
                        <a href="http://creativecommons.org/licenses/by/2.5/es/deed.ca" class="text-light">Creative Commons</a></small></small>
                    </p>
                </div>
                <div class="col-md-4 text-md-end">
                    <p class="mb-0">
                        <a href="https://github.com/catux" class="text-light me-3"><i class="fab fa-github"></i></a>
                        <a href="https://t.me/+UaRevB06YidmYTY0" class="text-light"><i class="fab fa-telegram"></i></a>
                    </p>
                </div>
            </div>
        </div>
    </footer>



</body>
</html>
